/**
 * Accounting Entries GraphQL Hook
 *
 * Provides data fetching for accounting entries generated by GL rules.
 * Uses GraphQL via Hasura with multi-tenant architecture.
 * This is a read-only view - recognition is handled automatically by batch processing.
 */

import { useCallback, useState } from 'react';
import { useGraphQL } from './useGraphQL';
import {
  AccountingEntry,
  AccountingEntryStatus,
  PaginationInfo,
} from '../types/gl-rules';

// Static table names using reference schema (tenant specified via header)
const ACCOUNTING_ENTRIES_TABLE = 'jsg_reference_schema_accounting_entries';
const ACCOUNTS_TABLE = 'jsg_reference_schema_accounts';

/**
 * Filter state for accounting entries
 */
export interface AccountingEntriesFilters {
  /** Start date for created_at filter (YYYY-MM-DD) */
  startDate: string | null;
  /** End date for created_at filter (YYYY-MM-DD) */
  endDate: string | null;
  /** Status filter (pending, recognized, reversal) */
  status: AccountingEntryStatus | null;
  /** GL Account ID filter */
  accountId: number | null;
  /** Search by booking reference */
  search: string;
}

/**
 * Summary statistics for accounting entries
 */
export interface AccountingEntriesSummary {
  /** Total number of entries */
  totalCount: number;
  /** Number of pending entries */
  pendingCount: number;
  /** Number of recognized entries */
  recognizedCount: number;
  /** Number of reversal entries */
  reversalCount: number;
  /** Total amount of all entries */
  totalAmount: number;
  /** Total positive (credit) amount */
  totalCredit: number;
  /** Total negative (debit) amount */
  totalDebit: number;
}

/**
 * Default filters - last 30 days
 */
function getDefaultFilters(): AccountingEntriesFilters {
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - 30);

  return {
    startDate: startDate.toISOString().split('T')[0],
    endDate: endDate.toISOString().split('T')[0],
    status: null,
    accountId: null,
    search: '',
  };
}

/**
 * Raw entry from GraphQL (before transformation)
 */
interface RawAccountingEntry {
  id: number;
  amount: string | number;
  recognised_at: string | null;
  recognised_at_local: string | null;
  association_type: string | null;
  association_id: number | null;
  batch_run_id: number | null;
  deleted: boolean;
  created_at: string;
  updated_at: string;
  account_id: number;
  account?: {
    id: number;
    name: string;
    external_id: string;
  };
}

/**
 * Derive status from entry data
 */
function deriveStatus(entry: RawAccountingEntry): AccountingEntryStatus {
  const amount = typeof entry.amount === 'string' ? parseFloat(entry.amount) : entry.amount;

  if (entry.recognised_at === null) {
    return 'pending';
  }
  if (amount < 0) {
    return 'reversal';
  }
  return 'recognized';
}

/**
 * Transform raw entry to AccountingEntry
 */
function transformEntry(raw: RawAccountingEntry): AccountingEntry {
  const amount = typeof raw.amount === 'string' ? parseFloat(raw.amount) : raw.amount;
  const status = deriveStatus(raw);

  return {
    id: raw.id,
    money_id: raw.association_type === 'money' ? raw.association_id : null,
    status,
    sale_date: null, // Would need a join to money table to get this
    entry_lines: [], // Simplified - entries are single-line in this schema
    amount,
    account_id: raw.account_id,
    account_name: raw.account?.name,
    account_external_id: raw.account?.external_id,
    recognised_at: raw.recognised_at,
    recognised_at_local: raw.recognised_at_local,
    association_type: raw.association_type,
    association_id: raw.association_id,
    deleted: raw.deleted,
    created_at: raw.created_at,
    updated_at: raw.updated_at,
    batch_run_id: raw.batch_run_id,
  };
}

export function useAccountingEntries() {
  const { query } = useGraphQL();

  // State
  const [entries, setEntries] = useState<AccountingEntry[]>([]);
  const [summary, setSummary] = useState<AccountingEntriesSummary>({
    totalCount: 0,
    pendingCount: 0,
    recognizedCount: 0,
    reversalCount: 0,
    totalAmount: 0,
    totalCredit: 0,
    totalDebit: 0,
  });
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [filters, setFiltersState] = useState<AccountingEntriesFilters>(getDefaultFilters);
  const [pagination, setPagination] = useState<PaginationInfo>({
    page: 1,
    page_size: 20,
    total_items: 0,
    total_pages: 0,
  });

  /**
   * Build where clause object based on filters (for GraphQL variables)
   */
  const buildWhereClause = useCallback((currentFilters: AccountingEntriesFilters): Record<string, unknown> => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const where: Record<string, any> = {
      deleted: { _eq: false },
    };

    // Date range filter
    if (currentFilters.startDate) {
      where.created_at = { ...where.created_at, _gte: `${currentFilters.startDate}T00:00:00` };
    }
    if (currentFilters.endDate) {
      where.created_at = { ...where.created_at, _lte: `${currentFilters.endDate}T23:59:59` };
    }

    // Account filter
    if (currentFilters.accountId) {
      where.account_id = { _eq: currentFilters.accountId };
    }

    // Status filter - this requires computed logic based on recognised_at and amount
    if (currentFilters.status === 'pending') {
      where.recognised_at = { _is_null: true };
    } else if (currentFilters.status === 'recognized') {
      where.recognised_at = { _is_null: false };
      where.amount = { _gt: '0' };
    } else if (currentFilters.status === 'reversal') {
      where.recognised_at = { _is_null: false };
      where.amount = { _lt: '0' };
    }

    return where;
  }, []);

  /**
   * Fetch entries with filters and pagination
   * Uses a two-query approach: first fetches entries, then fetches accounts separately
   */
  const fetchEntries = useCallback(async (
    currentFilters: AccountingEntriesFilters = filters,
    page: number = 1,
    pageSize: number = 20
  ) => {
    setLoading(true);
    setError(null);

    const whereClause = buildWhereClause(currentFilters);
    const offset = (page - 1) * pageSize;

    // First query: fetch entries without account relationship
    // Use GraphQL variables for proper query syntax
    const entriesQuery = `
      query GetAccountingEntries($where: ${ACCOUNTING_ENTRIES_TABLE}_bool_exp!, $limit: Int!, $offset: Int!) {
        entries: ${ACCOUNTING_ENTRIES_TABLE}(
          where: $where
          order_by: { created_at: desc }
          limit: $limit
          offset: $offset
        ) {
          id
          amount
          recognised_at
          recognised_at_local
          association_type
          association_id
          batch_run_id
          deleted
          created_at
          updated_at
          account_id
        }
        total: ${ACCOUNTING_ENTRIES_TABLE}_aggregate(where: $where) {
          aggregate {
            count
          }
        }
      }
    `;

    try {
      const entriesResponse = await query<{
        entries: Omit<RawAccountingEntry, 'account'>[];
        total: { aggregate: { count: number } };
      }>(entriesQuery, { where: whereClause, limit: pageSize, offset });

      const rawEntries = entriesResponse.data.entries;
      const totalItems = entriesResponse.data.total.aggregate.count;

      // Get unique account IDs
      const accountIds = [...new Set(rawEntries.map((e) => e.account_id).filter(Boolean))];

      // Second query: fetch accounts if we have any account IDs
      let accountsMap: Record<number, { name: string; external_id: string }> = {};
      if (accountIds.length > 0) {
        const accountsQuery = `
          query GetAccounts($accountIds: [Int!]!) {
            accounts: ${ACCOUNTS_TABLE}(
              where: { id: { _in: $accountIds }, deleted: { _eq: false } }
            ) {
              id
              name
              external_id
            }
          }
        `;
        const accountsResponse = await query<{
          accounts: Array<{ id: number; name: string; external_id: string }>;
        }>(accountsQuery, { accountIds });

        accountsMap = accountsResponse.data.accounts.reduce((acc, a) => {
          acc[a.id] = { name: a.name, external_id: a.external_id };
          return acc;
        }, {} as Record<number, { name: string; external_id: string }>);
      }

      // Combine entries with account data
      const entriesWithAccounts: RawAccountingEntry[] = rawEntries.map((entry) => ({
        ...entry,
        account: entry.account_id ? accountsMap[entry.account_id] : undefined,
      }));

      const transformedEntries = entriesWithAccounts.map(transformEntry);

      setEntries(transformedEntries);
      setPagination({
        page,
        page_size: pageSize,
        total_items: totalItems,
        total_pages: Math.ceil(totalItems / pageSize),
      });

      return transformedEntries;
    } catch (err) {
      const message = err instanceof Error ? err.message : 'Failed to fetch accounting entries';
      setError(message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [query, buildWhereClause, filters]);

  /**
   * Build a where clause string for summary queries.
   * Combines date range into a single created_at object to avoid duplicate keys.
   */
  const buildSummaryWhere = useCallback((
    currentFilters: AccountingEntriesFilters,
    extraConditions: string[] = []
  ): string => {
    const conditions: string[] = ['deleted: { _eq: false }'];

    // Combine date range into a single created_at object
    if (currentFilters.startDate && currentFilters.endDate) {
      conditions.push(`created_at: { _gte: "${currentFilters.startDate}T00:00:00", _lte: "${currentFilters.endDate}T23:59:59" }`);
    } else if (currentFilters.startDate) {
      conditions.push(`created_at: { _gte: "${currentFilters.startDate}T00:00:00" }`);
    } else if (currentFilters.endDate) {
      conditions.push(`created_at: { _lte: "${currentFilters.endDate}T23:59:59" }`);
    }

    if (currentFilters.accountId) {
      conditions.push(`account_id: { _eq: ${currentFilters.accountId} }`);
    }

    conditions.push(...extraConditions);
    return `{ ${conditions.join(', ')} }`;
  }, []);

  /**
   * Fetch summary statistics for the current filters
   */
  const fetchSummary = useCallback(async (
    currentFilters: AccountingEntriesFilters = filters
  ) => {
    const baseWhere = buildSummaryWhere(currentFilters);
    const pendingWhere = buildSummaryWhere(currentFilters, ['recognised_at: { _is_null: true }']);
    const recognizedWhere = buildSummaryWhere(currentFilters, ['recognised_at: { _is_null: false }', 'amount: { _gt: "0" }']);
    const reversalWhere = buildSummaryWhere(currentFilters, ['recognised_at: { _is_null: false }', 'amount: { _lt: "0" }']);

    const q = `
      query GetAccountingEntriesSummary {
        total: ${ACCOUNTING_ENTRIES_TABLE}_aggregate(where: ${baseWhere}) {
          aggregate {
            count
            sum { amount }
          }
        }
        pending: ${ACCOUNTING_ENTRIES_TABLE}_aggregate(where: ${pendingWhere}) {
          aggregate {
            count
          }
        }
        recognized: ${ACCOUNTING_ENTRIES_TABLE}_aggregate(where: ${recognizedWhere}) {
          aggregate {
            count
            sum { amount }
          }
        }
        reversal: ${ACCOUNTING_ENTRIES_TABLE}_aggregate(where: ${reversalWhere}) {
          aggregate {
            count
            sum { amount }
          }
        }
      }
    `;

    try {
      const response = await query<{
        total: { aggregate: { count: number; sum: { amount: string | null } } };
        pending: { aggregate: { count: number } };
        recognized: { aggregate: { count: number; sum: { amount: string | null } } };
        reversal: { aggregate: { count: number; sum: { amount: string | null } } };
      }>(q);

      const totalAmount = parseFloat(response.data.total.aggregate.sum.amount || '0');
      const creditAmount = parseFloat(response.data.recognized.aggregate.sum.amount || '0');
      const debitAmount = Math.abs(parseFloat(response.data.reversal.aggregate.sum.amount || '0'));

      const newSummary: AccountingEntriesSummary = {
        totalCount: response.data.total.aggregate.count,
        pendingCount: response.data.pending.aggregate.count,
        recognizedCount: response.data.recognized.aggregate.count,
        reversalCount: response.data.reversal.aggregate.count,
        totalAmount,
        totalCredit: creditAmount,
        totalDebit: debitAmount,
      };

      setSummary(newSummary);
      return newSummary;
    } catch (err) {
      console.error('Failed to fetch summary:', err);
      // Don't throw - summary is supplementary
      return summary;
    }
  }, [query, buildSummaryWhere, filters, summary]);

  /**
   * Update filters and refetch
   */
  const setFilters = useCallback((newFilters: Partial<AccountingEntriesFilters>) => {
    setFiltersState((prev) => ({ ...prev, ...newFilters }));
  }, []);

  /**
   * Reset filters to defaults
   */
  const resetFilters = useCallback(() => {
    setFiltersState(getDefaultFilters());
  }, []);

  /**
   * Refetch with current filters
   */
  const refetch = useCallback(async () => {
    await Promise.all([
      fetchEntries(filters, pagination.page, pagination.page_size),
      fetchSummary(filters),
    ]);
  }, [fetchEntries, fetchSummary, filters, pagination.page, pagination.page_size]);

  /**
   * Go to a specific page
   */
  const goToPage = useCallback(async (page: number) => {
    await fetchEntries(filters, page, pagination.page_size);
  }, [fetchEntries, filters, pagination.page_size]);

  /**
   * Change page size
   */
  const setPageSize = useCallback(async (pageSize: number) => {
    await fetchEntries(filters, 1, pageSize);
  }, [fetchEntries, filters]);

  return {
    // Data
    entries,
    summary,

    // State
    loading,
    error,

    // Pagination
    pagination,
    goToPage,
    setPageSize,

    // Filters
    filters,
    setFilters,
    resetFilters,

    // Actions
    fetchEntries,
    fetchSummary,
    refetch,
  };
}
